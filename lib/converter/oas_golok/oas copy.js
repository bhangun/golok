import {getFront} from '../basic_template.js';
import {typeCheck, convertTypeByFramework, getLastWord,
} from '../../core/utils.js';
export {
  oas2golok, getEntities, getOperations, getProperties,
  getResponses,
};

/**
   * convertJson2Golok
   * @param {String} oas
   * @param {String} options
   * @return {String} model
   */
function oas2golok(oas, options) {
  const model = {};
  const entities = [];

  model.info = getInfo(oas);
  model.endpoint = getEndpoint(oas);
  model.applications = {};
  model.applications.appsName = options.appsName,
  model.applications.framework = options.framework,
  model.applications.packages = options.packages,
  model.applications.frontend = getFront(model);
  model.entities = getEntities(oas.components.schemas, entities, oas, model);
  model.operations = getOperations(oas, model.entities, model, options);
  return model;
}

/**
   * get info
   * @param {object} oas
   * @param {object} model
   * @return {array} value
   */
function getInfo(oas, model) {
  const info = {};
  return info;
}

/**
   * get endpoint
   * @param {object} oas
   * @param {object} model
   * @return {array} value
   */
function getEndpoint(oas, model) {
  const info = {};
  return info;
}

/**
   * getEntities
   * @param {object} components
   * @param {object} entities
   * @param {object} oas
   * @param {object} model
   * @return {array} value
   */
function getEntities(components, entities, oas, model) {
  Object.entries(components).forEach((e) => {
    const entity = {};
    entity.name= e[0];

console.log('>>>>>>>>>>>>>', e[1]);
    if (e[1].modelOnly) {
      entity.modelOnly = e[1].modelOnly;
    }

    if (e[1].properties) {
      entity.properties= getProperties(e[1].properties,
          entity.name, entities, entity.modelOnly);
      entities.push(entity);
    }
  });

  return entities;
}

/**
   * getProperties
   * @param {object} properties
   * @param {String} entityName
   * @param {object} entities
   * @param {bool} modelOnly
   * @return {String} value
   */
function getProperties(properties, entityName, entities, modelOnly) {
  const props = [];
  Object.entries(properties).forEach((e) => {
    const prop = {};
    prop.name = e[0];

    if (e[1].example) {
      prop.example = e[1].example;
    }

    if (prop.nullable) {
      prop.nullable= e[1].nullable;
    }

    // If has relationship to entity
    if (e[1].$ref) {
      prop.ref = getLastWord(e[1].$ref);
    }

    // If type more than one
    if (e[1].oneOf) {
      prop.type = '';
      prop.oneOf = [];
      e[1].oneOf.forEach((i) => {
        const o = {};
        // Assign type
        o.type= i.type? convertTypeByFramework(i, undefined, ) : i;

        // If array
        if (typeCheck(i.type) === 'array' && i.items) {
          o.type = convertTypeByFramework(i);
          o.items = i.items;
        }
        prop.oneOf.push(o);
      });
    }

    // If has type
    if (e[1].type) {
      // Type is Object
      if (e[1].type === 'object' && e[1].properties) {
        console.log('-----------------------', prop.name + '----'+ entityName);
        prop.ref = objectBuilder(e[1].properties, prop.name,
            entityName, entities, modelOnly);
      // Instead type directly convert to dart
      } else {
        prop.type = convertTypeByFramework(e[1]);
      }
    }

    props.push(prop);
  });

  return props;
}

/**
   * getEntities
   * @param {object} properties
   * @param {String} propName
   * @param {String} entityName
   * @param {object} entities
   * @param {bool} modelOnly
   * @return {String} value
   */
function objectBuilder(properties, propName, entityName, entities, modelOnly) {
  let obj = {};

  // New entity name using parent entity name and combine
  // with property name
  const name = entityName + propName;

  // modelOnly attribute can be use to determine new entity
  // generated by this objectBuilder method.
  if (!modelOnly) {
    obj = JSON.parse('{"'+name+'":{"modelOnly":true,"properties":'+
  JSON.stringify(properties)+'}}');

    // this new object/entity loop to add to main entities.
    getEntities(obj, entities);
  }

  // Just return the name of new entity
  return name;
}

/**
   * getEntities
   * @param {String} data
   * @param {String} entities
   * @param {String} model
   * @param {String} options
   * @return {String} value
   */
function getOperations(data, entities, model, options) {
  const operations = [];

  Object.entries(data.paths).forEach((e) => {
    const operation = {};
    // Path / URI
    operation.path = e[0];

    // Declare ops.methods as array
    operation.methods = [];

    // Looping each path methods
    Object.entries(e[1]).forEach((m) => {
      const method = {};

      method.name = m[0];
      method.responses = getResponses(m[1].responses, entities, model, options);
      method.parameters = getParameters(m[1].parameters,
          entities, model, options);

      operation.methods.push(method);
    });

    operations.push(operation);
  });
  return operations;
}

/**
   * getResponses
   * @param {String} data
   * @param {String} entities
   * @param {String} model
   * @param {String} options
   * @return {String} value
   */
function getResponses(data, entities, model, options) {
  const responses = [];
  Object.entries(data).forEach((r) => {
    const response = {};
    // Response code: 200|201|400|403|500
    response.code = r[0];
    // Response code description
    response.desc = r[1].description;

    if (r[1].content) {
      // Content type is array
      response.content = getContents(r[1].content, entities, model, options);
    }

    responses.push(response);
  });

  return responses;
}

/**
   * getParameters
   * @param {String} data
   * @param {String} entities
   * @param {String} model
   * @param {String} options
   * @return {String} value
   */
function getParameters(data, entities, model, options) {
  const parameters = [];
  if (data) {
    data.forEach((r) => {
      const param = {};
      param.name = r.

          parameters.push(param);
    });
  }

  return parameters;
}

/**
   * getContents
   * @param {String} data
   * @param {String} entities
   * @param {String} model
   * @param {String} options
   * @return {String} value
   */
function getContents(data, entities, model, options) {
  const contents = [];

  Object.entries(data).forEach((c) => {
    const content = {};
    // Content type: application/json | application/xml
    content.contentType = c[0];

    if (c[1].schema) {
      // { '$ref': '#/components/schemas/Error' }
      if (c[1].schema.$ref) {
        content.ref = getLastWord(c[1].schema.$ref);
      }

      if (c[1].schema.type) {
        /* {
          type: 'object',
          properties: { ok: { type: 'string', enum: [Array] } }
        } */
        if (c[1].schema.type === 'object') {
          // If properties declare as entity
          if (options.propertiesAsEntity) {
            const respEntityName = objectBuilder(c[1].schema.properties,
                response.code, 'Resp', entities, true);
            content.ref = respEntityName;
          } else {
            console.log(c[1].schema.properties);
            content.properties = getProperties(c[1].schema.properties,
                'Cont', entities, true);
          }
        }

        /*
        {
        type: 'array',
        items: { '$ref': '#/components/schemas/Users-Permissions-User' }
        }
        */
        if (c[1].schema.type === 'array') {
          console.log('array');
        }
      }

      /*
      {
        allOf: [
          { '$ref': '#/components/schemas/Users-Permissions-User' },
          { type: 'object', properties: [Object] }
        ]
      }
      */
      if (c[1].schema.allOf) {
        console.log('array');
      }
    }

    contents.push(content);
  });

  return contents;
}
